Trecerea de la o aplicație monolitică la una bazată pe microservicii uneori nu este
ușoară. Unul din principalele motive este o posibilitate de a regândii modul cum accesăm
anumite elemente. Atunci când totul se află în cadrul unui singur proces, acessarea datelor
devine mai grea întrucât nu avem acces la ele și uneori nu este rentabil să căutăm după ele.
Atunci când apelăm o funcție local, timpul necesar pentru executarea acesteia este neglijabil,
atunci când această funcție trebuie să apeleze un alt microserviciu, lucrurile se complică și
trebuie decis dacă chiar avem nevoie. Un apel făcut printr-o rețea mereu va avea o întârziere, de asemenea
cresc locurile în care acesta poate eșua. În dezvoltarea aplicațiilor mobile întrucât 
ne așteptam ca aplicația să reacționeze la atingeri, nu putem să facem anumite operații pe
thread-ul principal, acestea pot fi apelarea lucrurilor de pe Internet sau accesarea unei baze
de date (chiar și dacă este de tipul SQLite3 fiind locală), aceasta pune în perspectivă 
impactul pe care acest tip de apeluri le pot avea.

Atunci când modificăm modul în care comunică un microserviciu trebuie să avem grijă la modul
cum ar afecta alte microservicii, sau atunci când acest lucru este necesar trebuie să orchestrăm
aplicarea acestor schimbări. Un alt concept ce într-o arhitectură monolitică se tratează ușor
este tratarea erorilor, întrucât toate se întâmplă în același mediu de lucru putem avea o viziune
asupra ce poate să cadă și în ce mod. Într-un sistem distribuit, pot apărea mai multe tipuri
de erori care se datorează rețelor, de exemplu crash-uri de microservicii ce necesită resetări,
erori de omisie de mesaje, când încercăm să apelăm un microserviciu însă acesta nu trimite un răspund,
în același timp acest răspund poate să fie mult prea rapid și să nu putem să îl recepționăm
sau prea târziu și să considerăm că nu am primit, dar și erori arbitrare precum unele în care 
ne așteptăm la un răspund și nu primim ce avem nevoie.

Toate aceste aspecte trebuie tratate atunci când lucrăm cu microservicii, însă fiind vorba
de o arhitectură paralelă ce oferă independență avem flexibilitatea de a alege ce folosim și ce nu.
De aceea este important să alegem tehnologii și stiluri de comunicare care oferă 
performanțele dorite încercând să minizăm timpul de răspuns și tipurile de avarii ce pot apărea.

\subsection{Tipuri de comunicare}

La fel ca în comunicarea între procese sau în cadrul unui proces, există comunicare sincronă
ce introduce blocare la un anumit nivel și comunicare asincronă ce permite procesele să 
trateze cererile în momentul în care pot, aducând îmbunătățiri ale perfomanței dar crescând
dificultatea întelegeri și a modurilor în care aplicația poate cădea.

Cel mai simplu de înteles mod de comunicare este comunicarea sincronă bazată pe cerere și răspuns.
În cadrul acestuia un microserviciu face o cerere(indiferent de formă) către un alt microserviciu și așteaptă
un răspuns. Acest scenariu este extrem de familiar, semănând cu cererile către o bază de date sau către
un API extern, ceea ce le face ușor de implementat însă nu este o tactică eficientă în cadrul unui sistem distribuit
întrucât aduc dezavantaje precum apariția acestui blocaj, creșterea latenței dar și apariția
acestui cuplaj temporar întrucât se poate întâmpla ca unul dintre microservicii să nu fie același
ca cel care a răspuns întrucât a fost necesară o resetare. Acest tip de comunicare poate fi folosită
pentru microservicii simple dar trebuie evitat crearea unui șir întreg de cereri întrucât crește
timpul total de răspuns dar și apariția unui eșec în cascadă.

Însă, o arhitectură paralelă are posibilitatea creării a unui tip de comunicare asincronă ce
nu blochează funcționarea microserviciilor, adică ele nu așteaptă un răspuns direct. Avantajul
unui tip astfel tip de comunicare este posibilitatea tratării operațiunilor ce ar dura mai mult 
întrucât se elimină conceptul de cuplare temporară. Dezavantajul este creșterea nivelului de complexitate
și creșterea dificultății de monitorizare și de a manevra erorile, însă ar trebui să fie 
utilizată atunci când avem procese de lungă durată sau pentru a comunica cu mai multe microservicii 
în același timp.

Cel mai simplu mod de a implementa comunicarea asincronă este crearea de resurse partajate.
Un microserviciu adaugă date, fie într-o locație de stocare, adăugăm un fișier sau la o bază de date
adăugăm alte date, iar celelalte microservicii ce vor să acționeze în urma primirii acestei informații
doar verifică apariția de date noi, iar atunci când apare o prelucrează. Dezavantaje includ
necesitatea tratării cazurilor în care microserviciile ce scanează sunt căzute, iar în momentul
în care vor reveni sunt nevoie să trateze date noi dar și faptul că se realizează o formă
de cuplare asupra domeniului partajat. Această formă de comunicare poate fi folosită atunci 
când suntem restricționati de tehnologiile folosite, întrucât orice tip de sistem poate să
citească date dintr-un fișier dar și atunci când vrem să trimitem un volum de date ridicat.

Un alt tip de comunicare este cel sub formă cerere-răspuns, acesta poate fi sincron sau asincron.
În mod blocant, microserviciul ce face cererea va astepta un răspuns iar în funcție de acesta 
își va continua activitatea. În mod asincron, se va proceda în mod asemănător însă de data aceasta nu se
va mai aștepta un răspuns, sau cel puțin nu unul cu informația cerută. Acest lucru este mai dificil,
întrucât pentru a răspunde cererii, microserviciul trebuie să trimită unui microserviciu
specific răspunsul creat și există posibilitatea ca microserviciul ce inițiază cererea să
nu mai existe astfel am putea încerca ca orice microserviciu să poată să trateze orice cerere.
Putem folosi acest mod de implementare atunci când avem nevoie să avem o confirmare la 
cererile făcute și de asemenea este destul de ușor de implementat, cel puțin varianta blocantă.

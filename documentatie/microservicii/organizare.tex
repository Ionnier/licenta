\subsection{Consum}

Atunci când construim un sistem, ne așteptăm să îl dăm în folosință pentru cineva,
fie clienți sau ca asistent al unui sistem existent. Însă în general acești clienți pot să
nu consume chiar sistemul direct întrucât acesta poate fi complex, ci putem să îi oferim printr-o
interfață construită tot de noi (în cazul aplicațiilor, putem considera front-end-ul o astfel
de interfață), astfel putem avea ca responsabilitate și crearea unui astfel de lucru.

În modul tradițional de lucru, am avea dezvoltatori grupați în funcție de rolul și platforma pe care
lucrează, astfel toți cei responsabili de o anumită componentă mai mare (de exemplu domeniu
sau prezentare) ar fi în același loc. Acest tip de organizare ne permite să avem o 
experiență identică la același nivel, însă comunicările între nivele pot fi afectate, astfel 
s-ar putea introduce probleme de sincornizare.

O metodă mai eficientă de organizare este gruparea dezvoltatorilor în funcție de locul în care
aceștia lucrează, astfel toți cei responsabili la toate nivelele de o anumită componentă a
sistemului nostru vor lucra împreună. Acest mod ne permite un control mult mai bun, având
metode de schimbări la orice nivel, astfel atunci când avem o inițiativă, aceasta e mai ușor 
de implementat și nu depindem de echipe exterioare pentru care trebuie șă așteptăm 
o implementare.

Construirea unei interfețe grafice poate devenii dificilă. În cadrul unei companii
ce oferă mai multe produse putem fi tentați să creăm o echipă dedicată pentru aplicațiile
pe care utilizatorii le-ar folosi, astfel aceasta ar fi consistentă tuturor. Această abordare poate
crea probleme atunci când vrem să lansăm caracteristici noi, de aceea o idee mai bună ar fi
crearea unei echipe ce va lucra în cadrul mai multor echipe, având posibilitatea să schimbe
proiectele.

Organizarea construirii interfețelor grafice poate fi făcută în mai multe moduri.
Cea mai simplă variantă presupune existența unei aplicații monolitice, în cadrul
acesteia consumăm API-urile propriu zise fără a face vreo optimizare modului cum
sunt făcute. Dezavantajul unei astfel de abordări este decuplarea între backend și frontend
dezvoltarea caracteristiciilor acestora nu poate fi la fel de bine coordonată. În același stil,
crearea multor cereri poate să cauzeze probleme legate de memorie, astfel acestea nu sunt
efectuate eficient.

O versiune mai avansată bazată pe framework-urile noi de dezvoltare este microfront-end-uri,
în cazul acesteia echipele furnizează un UI ce poate fi lansat independent de UI-urile
existente. O astfel de abordare le permite echipelor să își creeze UI-ul independent de celelalte
și acestea rămânând să se lanseze aproape independent, dar uneori tot combinat.

Această abordare poate fi implementată în mai multe moduri. Una dintre acestea este decompoziția
site-ului pe pagini, fiecare echipă fiind responsabilă de un anumit endpoint de pagini pe
site-ul mare. Aceasta le permite să fie independente întrucât livrarea paginilor este
independentă de paginile existente pe care server-ul trebuie să le arate.

O abordare mai dificlă de implementat, este separarea unei pagini în funcție de secțiile
pe care vrem ca acestea să le cuprindă, astfel fiecare echipă ar fi responsabilă de o componentă
ce apare pe o pagină la un anumit moment. Implementarea unei astfel de soluții ar fi ca
fiecare echipă să își construiască elementele ce vor să fie disponibile pe website și crearea
unei metode de agregare ale tuturor elementelor create. Din acest motiv, deși elementele sunt
separate acestea tot trebuie să fie integrate, iar crearea unui comportament împărțit
în cadrul mai multor elemente poate fi dificilă.

Unul din dezavantajele a unui front-end monolitic era numărul mare de cereri ce ar fi trebuit să
fie făcute către mai multe microservicii pentru o singură pagină. Pentru a rezolva problema aceasta
putem să folosim un intermediar ce are ca rol această agregare a datelor, astfel de pe dispozitiv
facem un singur call însă în spate sunt făcute mai multe. Dificultățile implementarii ar consta în
coordonarea echipelor, întrucât acest intermediar nu ar avea o echipă directă ci toți ar contribui la el.
În același stil ar exista dificultăți de tratare al numărului de informații pe care tipuri
de dispozitive le-ar folosi dar și de autentificare, întrucât totul devine agregat de un intermediar ce
ar trebui să aibă acces la toate resursele pe care le oferim.

Oferirea de asistență pentru diferitele platforme ne-a dus la crearea conceptului de Backend for Frontend,
astfel pentru fiecare tip de dispozitiv ce ar avea nevoie să ne acceseze sistemul,
am crea un backend specializat ce s-ar ocupa doar de o anumită experiență. Această abordare poate
avea sens dacă se fac multe apeluri peste rețea și dacă echipele de front end sunt decuplate de cele de backend.
Implementarea poate fi făcută de exemplu folosind GraphQL.

\subsection{Structură}

Nu este ceva nou faptul că aplicațiile mari sunt sunt create de mai multe persoane. Acestea pot fi
organizate în mai multe feluri și în același timp, fac parte din mai multe echipe și dintr-o
organizație ierarhică în cadrul companiei. Toate acestea au efect asupra modului în care
software-ul este dezvoltat.

În „How Do Committees Invent” publicat în Datamation în Aprilie 1968, Melvin Conway afirmă
că „Orice organizație ce crează un sistem, inevitabil va crea un design în care structura
va copia structura de comunicare a companiei” („Any organization that designs a system (defined more broadly here than
just information systems) will inevitably produce a design whose structure is a copy of the organization's
communication structure.”). Această „lege” practic afirăm că dacă am avea mai multe echipe ce ar
trebui să se ocupe de un sistem, atunci acestea își vor repartiza părțile astfe încât să lucreze fiecare,
deci se va ajunge asemănător la structura companiei.

Modul de organizare în companie dar și al echipelor influențează evoluția sistemului. Astfel,
unul din obiectivele pe care le putem crea este crearea independenței echipelor, acesta duce
la crearea unor organizații decuplate ce poate duce la eficientizarea modului de lucru.

Există probleme al căror eficientizare se poate face prin creșterea numărului de persoane,
în acest caz există multe exemple atunci când era prezentată regula de trei simplă, precum 
muncitorii pe șantier, aceștia au anumite cerințe ce pot să se desfășoare în paralel, astfel
adăugarea de mai multe persoane ar apropia data finalizării. Însă unele probleme nu se 
rezolvă în același stil, în absența capacității de paralelizare a task-urilor s-ar putea să 
înrăutățim situația. 

În acest context, alegerea unui număr potrivit de persoane într-o echipă poate fi dificlă.
Aceasta trebuie să aibă suficiente persoane în cât să fie independente. În cadrul Amazon,
s-a format conceptul de „Two-Pizza Team”, astfel în mod colocvial o echipă ar trebui să poată
fi suficient de mare încât să nu exite probleme în împărtășirea a două pizza în cadrul lor, 
și să fie suficient. Comunicarea ar trebui să fie eficientă în cadrul echipei iar între echipe
să fie limitată pentru a se preveni co-dependența în cazuri mari pentru că scopul 
este crearea unor echipe autonome.

Crearea unor echipe autonome duce la crearea unor deținători asupra microserviciilor create
de aceștia. Aceasta se numește o deținere puternică asupra acestuia, astfel doar echipa 
care deține microserviciul poate să dețină ce elemente intră în cod. Acest lucru se face
prin intermediul pull request-urilor, avantajul fiind crearea unui microserviciu stabil 
întrucât singurele modificări aduse sunt evaluate de persoane ce cunosc foarte bine proiectul.

În mod opus, putem avea microservicii ce au scop comun, astfel nu sunt deținute de nimeni și 
oricine poate aduce modificări acestuia. Acest mod de organizare ne poate aduce posibilitatea
să aducem modificări mult mai rapide, însă necesită ca echipele ce lucrează asupra acestuia
să se coordoneze mai bine, mai ales când intră în discuție tehnologiile utilizate.

Scopul final al organizării este de a eficientiza procesul de dezvoltare. Pentru a face asta, 
pot exista situații ce pot necesita acțiuni hibride.

De exemplu, combinând cele două abordări, putem avea un microserviciu deținut de mai multe echipe.
Acest lucru se poate întâmăla atunci când coeziunea este ridicată și decuplarea poate cauza
mai multe probleme decât ne dorim. Însă având mai multe echipe se pot cauza probleme în modurile de lansare
și introducerea schimbărilor ce pot strica anumite părți din alte microservicii, astfel 
aducem câteva din probleme unei arhitecturi monolitice însă la un nivel mai mic.

Pentru a crea o colaborare mai eficientă asupra codului comun, putem crea un mediu de lucru in 
stilul open-source intern, astfel toate echipele pot contribuii însă există anumite persoane mai implicate
în proiect care pot să aprobe shimbările. Acest mod poate avea sens și poate avea destul de eficient 
pe termen lung însă ar trebui ca proiectul să aibă un anumite de nivel de maturitate, astfel 
încât să existe o anumită arhitectură ce trebuie să fie urmată.

Un alt concept ce poate apărea este posibilitatea creării unui microserviciu dintr-unul existent.
Astfel putem avea o bază ce este liberă pentru toți și pentru funcționalitățile specifice 
se poate crea un synced fork al acestuia, asemănător moștenirii din OOP. Însă adoptarea unor 
astfel de schimbări trebuie să fie suportată de microserviciile cu care comunică.
